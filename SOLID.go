package main

/*
*
객체지향 설계에는 유명한 SOLID 원칙이하는게 존재함, SOLID 는 각각의 중요한 원칙 5가지의 앞자리 글자를 따서 만듬
S: Single Responsibility Principle (단일 책임 원칙)
O: Open/Closed Principle (개방/폐쇄 원칙)
L: Liskov Substitution Principle (리스코프 치환 원칙)
I: Interface Segregation Principle (인터페이스 분리 원칙)
D: Dependency Inversion Principle (의존 관계 역전 원칙)

이 각각의 원칙은 필수사항은 아니지만 이걸 기반으로 설계한다면 객체 지향적으로 더 좋은 설계가 가능함
설계란, 코드를 이루는 각 모듈 간의 의존 관계를 나타냄 > 이 의존 관계가 어떻게 구성되느냐에 따라서 코드의 재사용성, 유지보수성, 확장성이 올라감
또한, 코드를 정말 많은 사람들이 건드리면서 작업할텐데 요런 면에서도 의미가 있음

나쁜 설계를 나타내는 3가지 지표가 존재
경직성 : 모듈간의 결합도가 너무 높아서, 코드를 변경하기가 매우 어려운 코드
부서지기 쉬움 : 어디 하나를 고쳐버리면 같이 건드려줘야하는게 너무 많은 그런 어려운 코드
부동성 : 코드를 현재 애플리케이션에서 분리해서 다른 곳에서도 사용하고 싶지만, 모듈 간의 결합도가 너무 높아서 못 옮기는 >> 코드 재사용률이 현저하게 떨어짐
이 3가지 경우가 결국 "상호 결합도가 매우 높고, 응집도가 낮은 경우"
상호 결합도가 높다면, 경직성이 증가되고, 수정이 어려워우며 코드의 재사용성이 낮아짐
응집도가 낮다면, 코드가 자립하지 못하고 다른 모듈들에 의존하고 있다는 것

그래서 좋은 설계를 하려면 나쁘지 않게 설계하면 됨
즉, "상호 결합도가 낮고, 응집도가 높은" 설계를 해야함
상호 결합도가 낮아야, 모듈에서 분리도 쉽고, 모듈 간의 독립성을 가지기 때문에 수정이 쉬워지고 자연스럽게 모듈간의 완성도가 높아지면서 응집도 또한 높아짐

결과적으로 이 좋은 설계를 하기 위해서는 어떻게 해야하냐 > SOLID 원칙을 따르다보면 자연스럽게 좋은 설계로 이끌릴꺼임

1. Single Responsibility Principle (단일 책임 원칙)
>> 모든 객체는 책임을 하나만 져야 한다
이걸 적용하면, 코드의 재사용성이 높아짐

뭐 예를 들어서 FinanceReport 이라는 객체가 있고, sendReport 이라는 메소드가 있다고 가정했을 때
sendReport 에서 만약에 FinanceReport 이라는 객체를 파라미터로 받아버리면
HrReport 이라는 객체가 새로 나오고, sendReport 이라는 메소드를 사용해야 한다면, 기존의 코드를 봐서는 HrReport 을 파라미터로 받는 새로운 메소드를 만들어야함
이러한 이슈가 생기기 때문에
FinanceReport 를 Report 이라는 인터페이스를 통해서 분리하고, sendReport 에서는 report 인터페이스를 받아서 구현하도록 제공한다
그 의미는 결국 HrReport 가 새로 추가되어도, Report 이라는 인터페이스를 통해서 간단하게 sendReport 메소드를 사용할 수 있다는 것이다


2. Open-Close Principle (개방/폐쇄 원칙)
>> 확장엔 열려 있고 변경엔 닫혀 있다
이걸 적용하면, 상호 결합도를 줄여서 새로운 기능을 추가하는데 있어서 기존 구현을 변경하지 않아도 됨
여기서 포인트는, "프로그램에 기능을 추가할 때 기존 코드의 변경을 최소화 해야 한다"임

단일 책임 원칙에서 사용한 예시를 재탕해보면
sendReport 이라는 메소드의 내부애서 Report 이라는 인터페이스를 "어떤 방식으로 보낼꺼냐" 라는 로직이 있다고 가정해보자
그럼 뭐 email, 우편, sms 등등 방식이 다양하게 있을꺼고 이걸 구현하는 방법은? > switch 문으로 파라미터를 기반으로 막 구현해두겠지?
그러다가 이제 fax 라는 방식이 추가되었다, 그럼 결국 "기존에 돌고 있던" sendReport 메소드를 수정해야하는 이슈가 생김

그래서 이걸 좀 더 개방/폐쇄 원칙을 적용하면,
ReportSender 라는 인터페이스를 만들어주고, 그 안에 Report 객체를 파라미터로 받는 메소드를 만들어준다
그리고 EmailSender 를 구현, FaxSender 를 구현 이렇게 계속해서 새로운 객체를 추가하면서 각각에 대한 로직을 구현해주면 된다


3. Liskov Substitution Principle (리스코프 치환 원칙)
>> q(x) 을 타입 T 인 객체 x 에 대해 증명할 수 있는 속성이라고 가정하고 > S 가 T 을 상속하는 하위 타입이면, q(y) 는 타입 S 의 객체 y 에 대해서 증명할 수 있어야 한다
길지만, 결국 예상하지 못한 작동을 예방하는 것이 가능하다

이건 당연한 이야기를 하는거긴 하다
Report 이라는 인터페이스가 있고, FinanceReport 객체와 HrReport 객체가 있다 + 그리고 q(* Report) 이라는 메소드가 있다
여기서 q(* Report) 이라는 메소드는 파라미터로 FinanceReport 타입의 객체를 넣어도 잘 수행되어야 하고, HrReport 객체를 넣어도 잘 수행되어야 한다

결국, 리스코프 치환 원칙에 입각한 코드는, 함수 계약 관계를 잘 준수하는 코드임
+ go 에서는 상속을 지원하지 않기 때문에 이 원칙은 디폴트로 지켜지는 원칙이라고 볼 수 있음


4. Interface Segregation Principle (인터페이스 분리 원칙)
>> 클라이언트는 자신이 사용하지 않는 메소드에 의존하지 않아야 한다
인터페이스를 분리하면, 불필요한 메소드들과 의존 관계가 끊어져 더 가볍게 인터페이스를 사용하는 것이 가능함

Report 이라는 인터페이스가 있고 이놈은 FinanceReport 객체를 감싸기 위해서 만들어졌다고 해보자
그리고 FinanceReport 객체에는 기존에 sendReport, saveReport, printReport 라는 메소드가 있다고 가정해보자
그래서 FinanceReport 에서 Report 을 도출해나가는 과정에서 기존에 있던 sendReport, saveReport, printReport 이라는 메소드를 다 인터페이스에 구현을 했다고 가정하자
여기서 HrReport 객체가 sendReport 메소들르 사용하기 위해서 Report 이라는 인터페이스를 구현하려고 하는 순간, 자기는 필요없는 saveReport, printReport 메소드들을 다 구현해줘야하는 이슈가 있다

이걸 해결하기 위해서 Report 인터페이스에서는 sendReport 이라는 메소드만 포함시켜주고, saveReport, printReport 메소드는 뭐 ReportSetting 인터페이스로 빼준다
그리고 FinanceReport 에서는 Report, ReportSetting 인터페이스 2개 다 구현해서 사용하면 되는거고, HrReport 에서는 Report 인터페이스만 구현해서 사용하면 되는거다


5. Dependency Inversion Principle (의존 관계 역전 원칙)
>> 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 역전시킴으로써, 상위 계층이 하위 계층의 구현으로부터 독립되게 함
원칙 1 : 상위 모듈은 하위 모듈에 의존해선 안되고, 둘 다 추상 모듈에 의존해야 한다
원칙 2 : 추상 모듈은 구체화된 모듈에 의존해선 안됨, 구체화된 모듈은 추상 모듈에 의존해야 함

이걸 통해서
구체화된 모듈이 아닌 추상 모듈에 의존함으로써 확장성이 증가
상호 결합도가 낮아져서 다름 프로그램으로 이식성이 증가


원칙 1을 생각해봤을 때, 우린 문제점을 해결하기 위해서, 위에서 아래로 내려가는 사고방식인, 탑다운방식을 기반으로 해결법을 찾는다
예를 들어서 키보드를 입력을 받은 내용을 네트워크를 통해서 전송한다 라고 생각하면
전송
키보드, 네트워크
이런식으로 탑다운 방식으로 생각한다
전송의 동작은, 키보드라는 하위 모듈에서 값을 읽어서 네트워크라는 하위 모듈로 쓸 수 있다
근데 이건 키보드, 네트워크 모두가 전송에 결합되어 있는 방식이다 > 이걸 해결하기 위해서는 "전송"이란 모듈은 키보드, 네트워크 모듈을 직접적으로 사용하기 보다는
"입력", "출력"이라는 추상 모듈을 사용하도록 설정해주고, 키보드, 네트워크 모듈은 "입력", "출력" 모듈을 구현하도록 해주면
추상 모듈에 의존하도록 설정된다 > 이걸 통해서 결합도가 낮아지고, 독립성이 높아져서 확장성도 함께 증가한다

원칙 2을 설명하기 위해서 예시를 들어보면
메일이라는 객체가 있고, 알람이라는 객체가 있다
여기서 메일 객체에서는 알람이라는 객체를 사용해서 "메일이 오면? 알람을 보낸다" 라는 로직이 있다고 가정해본다
이 상황만 딱 놓고보면, "메일"이라는 구체화된 모듈이 "알람"이라는 구체화된 모듈에 의존하고 있기 때문에 의존 관계 역전 원칙을 위반하고 있다

그래서 이걸 해결하는 방법은 "이벤트"라는 인터페이스로 빼고, "이벤트 리스너"라는 인터페이스를 뺀다
그리고 "이벤트" - 메일 , "이벤트 리스너" - 알람
이렇게 구현해주게되면, 어떠한 구체화된 모듈이 또 어떤 구체화된 모듈에 의존하지 않아 의존 관계 역전 원칙 2번을 지킬 수 있게 된다
그리고 앞으로도 메일 수신뿐만 아니라 키보드 입력이나 뭐 타이머 만료 등 다양하게 적용도 가능


결과적으로 SOLID 는 모두 공통된 목적을 가지고 있다
"결합도는 낮게 응집도는 높게"
잘 지키면서 코드 치자


*/

func main() {

}
