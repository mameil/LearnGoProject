package main

/*
*
객체지향 설계에는 유명한 SOLID 원칙이하는게 존재함, SOLID 는 각각의 중요한 원칙 5가지의 앞자리 글자를 따서 만듬
S: Single Responsibility Principle (단일 책임 원칙)
O: Open/Closed Principle (개방/폐쇄 원칙)
L: Liskov Substitution Principle (리스코프 치환 원칙)
I: Interface Segregation Principle (인터페이스 분리 원칙)
D: Dependency Inversion Principle (의존 관계 역전 원칙)

이 각각의 원칙은 필수사항은 아니지만 이걸 기반으로 설계한다면 객체 지향적으로 더 좋은 설계가 가능함
설계란, 코드를 이루는 각 모듈 간의 의존 관계를 나타냄 > 이 의존 관계가 어떻게 구성되느냐에 따라서 코드의 재사용성, 유지보수성, 확장성이 올라감
또한, 코드를 정말 많은 사람들이 건드리면서 작업할텐데 요런 면에서도 의미가 있음

나쁜 설계를 나타내는 3가지 지표가 존재
경직성 : 모듈간의 결합도가 너무 높아서, 코드를 변경하기가 매우 어려운 코드
부서지기 쉬움 : 어디 하나를 고쳐버리면 같이 건드려줘야하는게 너무 많은 그런 어려운 코드
부동성 : 코드를 현재 애플리케이션에서 분리해서 다른 곳에서도 사용하고 싶지만, 모듈 간의 결합도가 너무 높아서 못 옮기는 >> 코드 재사용률이 현저하게 떨어짐
이 3가지 경우가 결국 "상호 결합도가 매우 높고, 응집도가 낮은 경우"
상호 결합도가 높다면, 경직성이 증가되고, 수정이 어려워우며 코드의 재사용성이 낮아짐
응집도가 낮다면, 코드가 자립하지 못하고 다른 모듈들에 의존하고 있다는 것

그래서 좋은 설계를 하려면 나쁘지 않게 설계하면 됨
즉, "상호 결합도가 낮고, 응집도가 높은" 설계를 해야함
상호 결합도가 낮아야, 모듈에서 분리도 쉽고, 모듈 간의 독립성을 가지기 때문에 수정이 쉬워지고 자연스럽게 모듈간의 완성도가 높아지면서 응집도 또한 높아짐

결과적으로 이 좋은 설계를 하기 위해서는 어떻게 해야하냐 > SOLID 원칙을 따르다보면 자연스럽게 좋은 설계로 이끌릴꺼임
*/
func main() {

}
