package main

/**
	고루틴이란,
	Go 언어에서 관리하는 경량 스레드
	함수나 명령을 동시에 수행할 때 사용하고 이걸 기반으로 프로그램을 구현하는 것을 "동시성 프로그래밍"이라고 함

> 고루틴을 사용해서 여러 작업을 동시에 수행하는 것이 가능
> 고루틴은 Go 언어에 내장된 기능이여서 외부 라이브러리의 도움 없이 구현 가능
> 멀티코어 환경에서 cpu 를 효율적으로 사용해 빠른 성능 도출 가능
> 고루틴은 기존 OS 스레드에서 발생되는 컨텍스트 스위칭에 따른 성능 손실을 최소화해 효율적으로 사용할 수 있음
> 고루틴 사이에서 메모리 간섭으로 인해 발생하는 문제에 특히 신경써야함
*/

/**
스레드
컴퓨터로 하여금
한번에 한 프로세스만 동작시키는 작업을 싱글태스킹이라고 하고
여러 프로세스를 한꺼번에 동작시키는 작업을 멀티태스킹이라고 함

프로세스란, 메모리 공간에 로딩되어 동작하는 프로그램을 의미
프로세스는 스레드를 한 개 이상을 가지고 있음
스레드가 하나면, 싱글스레드 스레드가 여러개면 멀티스레드 환경이 되는거임

스레드는 실행 흐름이라고 볼 수 있음
초기 컴퓨터는 "천공카드"를 넣어서 cpu 로 하여금 해당 종이를 읽고 해당 종이에 작성된 내용을 수행하도록 되어있었는데
여기서 말하는 "천공카드"가 지금 기준으론 스레드 인것이다

하나의 cpu 코어로 생각하고 고민해보면
코어는 한번에 하나의 스레드만 수행할 수 있지만 스레드가 쭉 이어졌으면 한줄만 쭉해서 읽게될 것임
ex) -----------------------------코어------------------------------
근데 만약에 코어가 하나인데 여러 연속된 스레드를 읽고 싶을떈 어떻게 할까
>> 그 방법은 하나의 코어가 스레드 라인을 계속해서 바꿔가면서 스레드를 처리하면 사용자 입장에선 여러 스레드의 집합이 동시에 수행되는 것 처럼 보임
ex)
코어-----------------------------------------------------------
---코어--------------------------------------------------------
------코어-----------------------------------------------------
위처럼 코어가 스레드 라인을 돌아가면서 수행하면 된다

자 근데 문제는, cpu 코어도 사람 같이
다양한 스레드 라인을 변경해가면서 작업을 수행하게되면 그것도 다 컴퓨터에서 비용이 든다, 사람처럼
그리고 위와 같이 스레드 라인을 변경하는 것을 컨텍스트 스위칭이라고 하고, 위에서 언급한 비용이 바로 컨텍스트 스위칭 비용이다

컨텍스트 스위칭을 하기 위해서는 현재 진행하고 있는 스레드의 작업 상태를 보관해줘야 함 >> 그래야 다시 돌아왔을 때 마지막까지 진행한 부분의 다음부터 진행하니까
이떄, 보관하는 것들을 생각해보면 스레드의 명령포인터, 스택 메모리 등의 정보 등을 저장하는데, 이것을 보고 "스레드 컨텍스트"라고 부름

결론적으론, 스레드를 전환할 때마다 컨텍스트 정보를 저장하고, 복원하고 이러한 작업들이 결국 컨텍스트 스위칭 비용이 되는것이다
그래서 적당한 갯수를 넘어가는 갯수의 스레드를 넘나들면서 작업을 수행하면 성능이 떨어지게 되는 꼴임
(보통 코어 갯수의 두 배 이상 스레드를 만들면 스위칭 비용이 많이 든다고 함)

서론이 길었는데, go 언어에서는 걱정할 필요가 없다네 > cpu 코어마다 os 스레드를 하나만 할당해서 사용하기 때문에 go 언어에서는 컨텍스트 스위칭 비용이 발생하지 않는다
*/

func main() {

}
