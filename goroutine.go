package main

import (
	"fmt"
	"sync"
	"time"
)

/**
	고루틴이란,
	Go 언어에서 관리하는 경량 스레드
	함수나 명령을 동시에 수행할 때 사용하고 이걸 기반으로 프로그램을 구현하는 것을 "동시성 프로그래밍"이라고 함

> 고루틴을 사용해서 여러 작업을 동시에 수행하는 것이 가능
> 고루틴은 Go 언어에 내장된 기능이여서 외부 라이브러리의 도움 없이 구현 가능
> 멀티코어 환경에서 cpu 를 효율적으로 사용해 빠른 성능 도출 가능
> 고루틴은 기존 OS 스레드에서 발생되는 컨텍스트 스위칭에 따른 성능 손실을 최소화해 효율적으로 사용할 수 있음
> 고루틴 사이에서 메모리 간섭으로 인해 발생하는 문제에 특히 신경써야함
*/

/*
*
스레드
컴퓨터로 하여금
한번에 한 프로세스만 동작시키는 작업을 싱글태스킹이라고 하고
여러 프로세스를 한꺼번에 동작시키는 작업을 멀티태스킹이라고 함

프로세스란, 메모리 공간에 로딩되어 동작하는 프로그램을 의미
프로세스는 스레드를 한 개 이상을 가지고 있음
스레드가 하나면, 싱글스레드 스레드가 여러개면 멀티스레드 환경이 되는거임

스레드는 실행 흐름이라고 볼 수 있음
초기 컴퓨터는 "천공카드"를 넣어서 cpu 로 하여금 해당 종이를 읽고 해당 종이에 작성된 내용을 수행하도록 되어있었는데
여기서 말하는 "천공카드"가 지금 기준으론 스레드 인것이다

하나의 cpu 코어로 생각하고 고민해보면
코어는 한번에 하나의 스레드만 수행할 수 있지만 스레드가 쭉 이어졌으면 한줄만 쭉해서 읽게될 것임
ex) -----------------------------코어------------------------------
근데 만약에 코어가 하나인데 여러 연속된 스레드를 읽고 싶을떈 어떻게 할까
>> 그 방법은 하나의 코어가 스레드 라인을 계속해서 바꿔가면서 스레드를 처리하면 사용자 입장에선 여러 스레드의 집합이 동시에 수행되는 것 처럼 보임
ex)
코어-----------------------------------------------------------
---코어--------------------------------------------------------
------코어-----------------------------------------------------
위처럼 코어가 스레드 라인을 돌아가면서 수행하면 된다

자 근데 문제는, cpu 코어도 사람 같이
다양한 스레드 라인을 변경해가면서 작업을 수행하게되면 그것도 다 컴퓨터에서 비용이 든다, 사람처럼
그리고 위와 같이 스레드 라인을 변경하는 것을 컨텍스트 스위칭이라고 하고, 위에서 언급한 비용이 바로 컨텍스트 스위칭 비용이다

컨텍스트 스위칭을 하기 위해서는 현재 진행하고 있는 스레드의 작업 상태를 보관해줘야 함 >> 그래야 다시 돌아왔을 때 마지막까지 진행한 부분의 다음부터 진행하니까
이떄, 보관하는 것들을 생각해보면 스레드의 명령포인터, 스택 메모리 등의 정보 등을 저장하는데, 이것을 보고 "스레드 컨텍스트"라고 부름

결론적으론, 스레드를 전환할 때마다 컨텍스트 정보를 저장하고, 복원하고 이러한 작업들이 결국 컨텍스트 스위칭 비용이 되는것이다
그래서 적당한 갯수를 넘어가는 갯수의 스레드를 넘나들면서 작업을 수행하면 성능이 떨어지게 되는 꼴임
(보통 코어 갯수의 두 배 이상 스레드를 만들면 스위칭 비용이 많이 든다고 함)

서론이 길었는데, go 언어에서는 걱정할 필요가 없다네 > cpu 코어마다 os 스레드를 하나만 할당해서 사용하기 때문에 go 언어에서는 컨텍스트 스위칭 비용이 발생하지 않는다
*/
var wg sync.WaitGroup

func main() {

	/**
	고루틴의 사용
	기본적으로 모든 고 프로그램은 고루틴을 하나씩 사용하고 있고 그건 바로 "메인루틴"이다
	메인루틴은 main() 함수와 함께 시작되고, main() 함수가 종료되면 같이 종료됨

	고루틴을 생성하는 방법은
	>> go 함수_호출
	go 키워드를 쓰고 함수를 호출하면, 해당 함수를 수행하는 고루틴이 현재 해당 작업이 수행되는 고루틴에서 새롭게 하나가 떨어져나가면서 만들어진다
	PrintHangul(), PrintNumbers()
	*/
	go PrintHangul()
	go PrintNumber()
	time.Sleep(3 * time.Second) //3초 대기
	//결과 : 가 1 나 2 다 3 라 마 4 바 5 사
	//위 2 함수가 별도의 스레드에서 수행되기 댸문에 지멋대로 순서가 뒤죽박죽서 나오는걸 볼 수 있음

	//이렇게 순서를 보장하지 못하면 얼마나 불편한가?
	//순서를 특별하게 보장해야하는 케이스에는 특정 고루틴이 종료되는 것을 기다렸다가 수행하는 방법으로 순서를 보장하는 것이 가능하다
	//sync.WaitGroup 객체를 통해서 가능함
	//var wg sync.WaitGroup
	//wg.Add(3) //작업 갯수 설정
	//wg.Done() //작업이 완료될때마다 호출
	//wg.Wait() //모든 작업이 완료될 때까지 대기

	//SumAtoB
	wg.Add(10) //대기그룹에 10개를 설정
	for i := 0; i < 10; i++ {
		go SumAtoB(1, 100000000)
	}

	wg.Wait() //모든 작업이 끝나는걸 대기 + 원래라면 다 다른 스레드로해서 for 문 안에서 수행되는 모든 작업들은 별도의 고루팀에서 작업이 되면서 메인루틴도 수행이 되니까 바로 밑의 fmt.Println 을 찍어야 하는데
	//WaitGroup 이 끝날때까지 메인 루틴보고 기다리라고 해서 저게 수행되는걸 기다렸다가 맨 마지막에 fmt.Println 을 찍는 모습
	fmt.Println("모든 계산이 완료됨")

	/**
	고루틴의 동작 방법
	고루틴은 명령을 수행하는 단일 흐름으로 OS 스레드를 이용하는 경량 스레드임
	go 언어의 안에는 cpu코어, os스레드, 고루틴을 서로 조율하면서 사용해서 고루틴을 효율적으로 활용하고 있음

	모든 명령을 os 스레드를 통해서 cpu 코어에서 실행됨, 위에서 이야기한 거랑 같이해서 생각해보면 cpu코어와 스레드 사이에 os 스레드가 있는 느낌
	결국 go 언어로 만든 프로그램도 어떠한 os 위에서 수행되어야 하기 때문에 os 스레드를 만들어서 명령을 수행해야함
	만약에 메인 루틴만 존재한다고 가정해보면, OS 스레드를 하나 만들어 첫 번쨰 코어와 연결한다
	생긴건 아래와 같이 생김
	cpu코어 - os 스레드 1 - 고루틴1

	고루틴이 2개인 경우 + 코어가 2개인 경우
	코어가 많으면 각각의 코어에 프로세스를 할당해서 수행시켜주면 되는 간단한 이야기
	cpu코어1 - os스레드1 - 고루틴1
	cpu코어2 - os스레드2 - 고루틴2

	그런데 위 상황에서 누가 또 고루틴을 돌려버리면(고루틴3),
	어라라 일단 cpu 코어는 다 쓰고 있는 상황이라 일단 대기 라인에 들어가서 대기하다가
	cpu 코어를 선점하고 있는 고루틴이 종료되면 그 자리를 뺏는다
	cpu코어1 - os스레드1 - 고루틴1
	cpu코어2 - os스레드2 - 고루틴3
	여기서 특이사항?은 os 스레드는 교체하지 않고 그냥 고루틴 만 교체한다는 점

	예시로 네트워크 기능이 있다고 가정하고
	현재 cpu 코어 2개에 고루틴 1,3 이 할당되어있다고 해보자,
	근데 고루틴 3 이놈이 네트워크 수신을 대기하고 있는 상황이고 고루틴 4 라는 놈이 수행 대기 목록에서 고루틴 1,3 이 끝나느걸 기다리고 있으면
	알아서 대기 하고 있는 고루틴3을 대기목록으로 내리고, 대기 목록에 있는 고루틴4를 수행목록에다가 올린다

	컨텍스트 스위치이란, cpu 코어가 스레드를 변경하는 것을 지칭하는데,
	지금까지 그림에서 봐온 것 처럼 고루틴이 동작할 때는, 기본적으로 cpu 코어에 os 스레드를 연결시켜놓고, 수행되는 고루틴만 변경한다
	이건 결국 컨텍스트 스위칭이 일어나지 않음을 이야기하고, 이 때문에 고루틴을 막 사용하는 것에 대해서는 부담없이 사용할 수 있음
	*/

	/**
	이렇게 프로그램의 수행을 병렬로 동시에 수행하게 되면 문제점은 "동일한 메모리 자원"에 여러 고루틴이 접근하는 것이 문제가 될 수 있음
	동시성을 보장하기 위해서 뮤텍스를 사용해서 자원의 접근을 제한하는 방법이 있다
	뮤텍스는 mutual exclusion 을 줄인말이고, 상호배제의 의미를 가짐
	뮤텍스의 Lock() 을 통해서 락을 잡고 처리하고, Unlock() 을 통해서 락 해제를 해주면 대기하던 고루틴 중 하나가 이걸 획득함
	ex > Account, DepositAndWithdraw()
	*/
	var wg2 sync.WaitGroup
	account := &Account{0}
	wg2.Add(10)
	for i := 1; i < 10; i++ {
		go func() {
			for {
				DepositAndWithdraw(account)
			}
			wg2.Done()
		}()
	}
	wg2.Wait()

}

func PrintHangul() {
	hanguls := []rune{'가', '나', '다', '라', '마', '바', '사'}
	for _, v := range hanguls {
		time.Sleep(300 * time.Millisecond) //0.3초 씩 대기하면서 찍고
		fmt.Printf("%c ", v)
	}
}

func PrintNumber() {
	for i := 1; i <= 5; i++ {
		time.Sleep(400 * time.Millisecond) //0.4초씩 대기하면서 찍고
		fmt.Printf("%d ", i)
	}
}

func SumAtoB(a, b int) {
	sum := 0
	for i := 0; i <= b; i++ {
		sum += i
	}
	fmt.Printf("%d부터 %d까지의 합계는 %d입니다\n", a, b, sum)
	wg.Done()
}

type Account struct {
	Balance int
}

func DepositAndWithdraw(account *Account) {
	if account.Balance < 0 {
		panic(fmt.Sprintf("Balance should not be negative value: %d", account.Balance))
	}
	account.Balance += 1000
	time.Sleep(time.Millisecond)
	account.Balance -= 1000
}
