package main

import (
	"fmt"
	"sync"
	"time"
)

/**
	고루틴이란,
	Go 언어에서 관리하는 경량 스레드
	함수나 명령을 동시에 수행할 때 사용하고 이걸 기반으로 프로그램을 구현하는 것을 "동시성 프로그래밍"이라고 함

> 고루틴을 사용해서 여러 작업을 동시에 수행하는 것이 가능
> 고루틴은 Go 언어에 내장된 기능이여서 외부 라이브러리의 도움 없이 구현 가능
> 멀티코어 환경에서 cpu 를 효율적으로 사용해 빠른 성능 도출 가능
> 고루틴은 기존 OS 스레드에서 발생되는 컨텍스트 스위칭에 따른 성능 손실을 최소화해 효율적으로 사용할 수 있음
> 고루틴 사이에서 메모리 간섭으로 인해 발생하는 문제에 특히 신경써야함
*/

/*
*
스레드
컴퓨터로 하여금
한번에 한 프로세스만 동작시키는 작업을 싱글태스킹이라고 하고
여러 프로세스를 한꺼번에 동작시키는 작업을 멀티태스킹이라고 함

프로세스란, 메모리 공간에 로딩되어 동작하는 프로그램을 의미
프로세스는 스레드를 한 개 이상을 가지고 있음
스레드가 하나면, 싱글스레드 스레드가 여러개면 멀티스레드 환경이 되는거임

스레드는 실행 흐름이라고 볼 수 있음
초기 컴퓨터는 "천공카드"를 넣어서 cpu 로 하여금 해당 종이를 읽고 해당 종이에 작성된 내용을 수행하도록 되어있었는데
여기서 말하는 "천공카드"가 지금 기준으론 스레드 인것이다

하나의 cpu 코어로 생각하고 고민해보면
코어는 한번에 하나의 스레드만 수행할 수 있지만 스레드가 쭉 이어졌으면 한줄만 쭉해서 읽게될 것임
ex) -----------------------------코어------------------------------
근데 만약에 코어가 하나인데 여러 연속된 스레드를 읽고 싶을떈 어떻게 할까
>> 그 방법은 하나의 코어가 스레드 라인을 계속해서 바꿔가면서 스레드를 처리하면 사용자 입장에선 여러 스레드의 집합이 동시에 수행되는 것 처럼 보임
ex)
코어-----------------------------------------------------------
---코어--------------------------------------------------------
------코어-----------------------------------------------------
위처럼 코어가 스레드 라인을 돌아가면서 수행하면 된다

자 근데 문제는, cpu 코어도 사람 같이
다양한 스레드 라인을 변경해가면서 작업을 수행하게되면 그것도 다 컴퓨터에서 비용이 든다, 사람처럼
그리고 위와 같이 스레드 라인을 변경하는 것을 컨텍스트 스위칭이라고 하고, 위에서 언급한 비용이 바로 컨텍스트 스위칭 비용이다

컨텍스트 스위칭을 하기 위해서는 현재 진행하고 있는 스레드의 작업 상태를 보관해줘야 함 >> 그래야 다시 돌아왔을 때 마지막까지 진행한 부분의 다음부터 진행하니까
이떄, 보관하는 것들을 생각해보면 스레드의 명령포인터, 스택 메모리 등의 정보 등을 저장하는데, 이것을 보고 "스레드 컨텍스트"라고 부름

결론적으론, 스레드를 전환할 때마다 컨텍스트 정보를 저장하고, 복원하고 이러한 작업들이 결국 컨텍스트 스위칭 비용이 되는것이다
그래서 적당한 갯수를 넘어가는 갯수의 스레드를 넘나들면서 작업을 수행하면 성능이 떨어지게 되는 꼴임
(보통 코어 갯수의 두 배 이상 스레드를 만들면 스위칭 비용이 많이 든다고 함)

서론이 길었는데, go 언어에서는 걱정할 필요가 없다네 > cpu 코어마다 os 스레드를 하나만 할당해서 사용하기 때문에 go 언어에서는 컨텍스트 스위칭 비용이 발생하지 않는다
*/
var wg sync.WaitGroup

func main() {

	/**
	고루틴의 사용
	기본적으로 모든 고 프로그램은 고루틴을 하나씩 사용하고 있고 그건 바로 "메인루틴"이다
	메인루틴은 main() 함수와 함께 시작되고, main() 함수가 종료되면 같이 종료됨

	고루틴을 생성하는 방법은
	>> go 함수_호출
	go 키워드를 쓰고 함수를 호출하면, 해당 함수를 수행하는 고루틴이 현재 해당 작업이 수행되는 고루틴에서 새롭게 하나가 떨어져나가면서 만들어진다
	PrintHangul(), PrintNumbers()
	*/
	go PrintHangul()
	go PrintNumber()
	time.Sleep(3 * time.Second) //3초 대기
	//결과 : 가 1 나 2 다 3 라 마 4 바 5 사
	//위 2 함수가 별도의 스레드에서 수행되기 댸문에 지멋대로 순서가 뒤죽박죽서 나오는걸 볼 수 있음

	//이렇게 순서를 보장하지 못하면 얼마나 불편한가?
	//순서를 특별하게 보장해야하는 케이스에는 특정 고루틴이 종료되는 것을 기다렸다가 수행하는 방법으로 순서를 보장하는 것이 가능하다
	//sync.WaitGroup 객체를 통해서 가능함
	//var wg sync.WaitGroup
	//wg.Add(3) //작업 갯수 설정
	//wg.Done() //작업이 완료될때마다 호출
	//wg.Wait() //모든 작업이 완료될 때까지 대기

	//SumAtoB
	wg.Add(10) //대기그룹에 10개를 설정
	for i := 0; i < 10; i++ {
		go SumAtoB(1, 100000000)
	}

	wg.Wait() //모든 작업이 끝나는걸 대기 + 원래라면 다 다른 스레드로해서 for 문 안에서 수행되는 모든 작업들은 별도의 고루팀에서 작업이 되면서 메인루틴도 수행이 되니까 바로 밑의 fmt.Println 을 찍어야 하는데
	//WaitGroup 이 끝날때까지 메인 루틴보고 기다리라고 해서 저게 수행되는걸 기다렸다가 맨 마지막에 fmt.Println 을 찍는 모습
	fmt.Println("모든 계산이 완료됨")
}

func PrintHangul() {
	hanguls := []rune{'가', '나', '다', '라', '마', '바', '사'}
	for _, v := range hanguls {
		time.Sleep(300 * time.Millisecond) //0.3초 씩 대기하면서 찍고
		fmt.Printf("%c ", v)
	}
}

func PrintNumber() {
	for i := 1; i <= 5; i++ {
		time.Sleep(400 * time.Millisecond) //0.4초씩 대기하면서 찍고
		fmt.Printf("%d ", i)
	}
}

func SumAtoB(a, b int) {
	sum := 0
	for i := 0; i <= b; i++ {
		sum += i
	}
	fmt.Printf("%d부터 %d까지의 합계는 %d입니다\n", a, b, sum)
	wg.Done()
}
